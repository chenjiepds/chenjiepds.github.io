(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{109:function(t,a,e){"use strict";e.r(a);var s=e(0),i=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"git知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git知识"}},[t._v("#")]),t._v(" Git知识")]),t._v(" "),e("p",[t._v("本文主要介绍了git使用SSH密钥、入门知识、分支管理以及常用命令，掌握了一下内容，你就可以轻松的在工作送使用Git了。")]),t._v(" "),e("h2",{attrs:{id:"ssh密钥"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ssh密钥"}},[t._v("#")]),t._v(" SSH密钥")]),t._v(" "),e("p",[t._v("git使用https协议，每次pull, push都要输入密码，相当的烦。\n使用git协议，然后使用ssh密钥。这样可以省去每次都输密码。")]),t._v(" "),e("p",[t._v("需要三个步骤：")]),t._v(" "),e("p",[t._v("一、本地生成密钥对；")]),t._v(" "),e("p",[t._v("二、设置github上的公钥；")]),t._v(" "),e("p",[t._v("三、修改git的remote url为git协议。")]),t._v(" "),e("h3",{attrs:{id:"_1、生成密钥"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、生成密钥"}},[t._v("#")]),t._v(" 1、生成密钥")]),t._v(" "),e("p",[t._v("大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ cd ~/.ssh \n$ ls\nauthorized_keys2  id_dsa       known_hosts config            id_dsa.pub\n")])])]),e("p",[t._v("关键是看有没有用 something 和 something.pub 来命名的一对文件，这个 something 通常就是 id_dsa 或 id_rsa。有 .pub 后缀的文件就是公钥，另一个文件则是密钥。假如没有这些文件，或者干脆连 .ssh 目录都没有，可以用 ssh-keygen 来创建。该程序在 Linux/Mac 系统上由 SSH 包提供，而在 Windows 上则包含在 MSysGit 包里：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('$ ssh-keygen -t rsa -C "your_email@youremail.com"\n\n# Creates a new ssh key using the provided email # Generating public/private rsa key pair. \n\n# Enter file in which to save the key (/home/you/.ssh/id_rsa):\n')])])]),e("p",[t._v("直接Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行)：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Enter passphrase (empty for no passphrase): [Type a passphrase] \n# Enter same passphrase again: [Type passphrase again]\n")])])]),e("p",[t._v("完了之后，大概是这样。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Your identification has been saved in /home/you/.ssh/id_rsa. \n# Your public key has been saved in /home/you/.ssh/id_rsa.pub. \n# The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com\n")])])]),e("p",[t._v("这样。你本地生成密钥对的工作就做好了。")]),t._v(" "),e("h3",{attrs:{id:"_2、添加公钥到你的github帐户"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、添加公钥到你的github帐户"}},[t._v("#")]),t._v(" 2、添加公钥到你的github帐户")]),t._v(" "),e("p",[t._v("2-1、查看你生成的公钥：大概如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ cat ~/.ssh/id_rsa.pub  \n\nssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlE\nLEVf4h9lFX5QVkbPppSwg0cda3 Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA t3FaoJoAsncM1Q9x5+3V\n0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx NrRFi9wrf+M7Q== schacon@agadorlaptop.local\n")])])]),e("p",[t._v("2-2、登陆你的github帐户。然后 Account Settings -> 左栏点击 SSH Keys -> 点击 Add SSH key")]),t._v(" "),e("p",[t._v("2-3、然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，你随便填一个都行。")]),t._v(" "),e("p",[t._v("2-4、完了，点击 Add key。")]),t._v(" "),e("p",[t._v("这样，就OK了。然后，验证下这个key是不是正常工作。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ ssh -T git@github.com\n# Attempts to ssh to github\n")])])]),e("p",[t._v("如果，看到：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Hi username! You've successfully authenticated, but GitHub does not # provide shell access.\n")])])]),e("p",[t._v("就表示你的设置已经成功了。")]),t._v(" "),e("h3",{attrs:{id:"_3、修改你本地的ssh-remote-url-不用https协议，改用git-协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、修改你本地的ssh-remote-url-不用https协议，改用git-协议"}},[t._v("#")]),t._v(" 3、修改你本地的ssh remote url. 不用https协议，改用git 协议")]),t._v(" "),e("p",[t._v("** 确保：**")]),t._v(" "),e("p",[t._v("你已经init了一个空仓库。")]),t._v(" "),e("p",[t._v("你已经把远程git的url添加到了本地git仓库的配置文件")]),t._v(" "),e("p",[t._v("================================================")]),t._v(" "),e("p",[t._v("可以用git remote -v 查看你当前的remote url")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git remote -v\norigin https://github.com/someaccount/someproject.git (fetch)\norigin https://github.com/someaccount/someproject.git (push)\n")])])]),e("p",[t._v("可以看到是使用https协议进行访问的。")]),t._v(" "),e("p",[t._v("你可以使用浏览器登陆你的github，在上面可以看到你的ssh协议相应的url。类似如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git@github.com:someaccount/someproject.git\n")])])]),e("p",[t._v("这时，你可以使用 git remote set-url 来调整你的url。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git remote set-url origin git@github.com:someaccount/someproject.git\n")])])]),e("p",[t._v("完了之后，你便可以再用 git remote -v 查看一下。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git remote -v\norigin https://git@github.com:someaccount/someproject.git (fetch)\norigin https://git@github.com:someaccount/someproject.git (push)\n")])])]),e("p",[t._v("OK。")]),t._v(" "),e("p",[t._v("至此，你就可以省去输入密码的麻烦，也可以很安全的进行push,pull,fetch,checkout等操作了。")]),t._v(" "),e("p",[t._v("你可以用git fetch, git pull , git push。")]),t._v(" "),e("p",[t._v("「注意：」")]),t._v(" "),e("p",[t._v("第一次使用git push之前，需要对git push进行配置：")]),t._v(" "),e("p",[t._v("1.simple方式：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git config --global push.default.simple\n")])])]),e("p",[t._v("2.matching方式：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git config --global push.default.matching\n\nmatching means git push will push all your local branches to the ones with the same name on the remote. This makes it easy to accidentally push a branch you didn't intend to.\n")])])]),e("p",[t._v("matching与simple方式的push的区别是：matching会把你所有本地的分支push到远程仓库中对应匹配的分支。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("simple means git push will push only the current branch to the one that git pull would pull from, and also checks that their names match. This is a more intuitive behavior, which is why the default is getting changed to this.\n")])])]),e("p",[t._v("simple方式，只会push你已经从远程仓库pull过的分支，意思是你曾经pull了分支dev，那么当你使用缺省git push时，当前分支为dev，远程分支dev就会收到你的commit。")]),t._v(" "),e("p",[t._v("3.或者使用git push [远程仓库] [本地分支]")]),t._v(" "),e("h2",{attrs:{id:"入门知识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#入门知识"}},[t._v("#")]),t._v(" 入门知识")]),t._v(" "),e("h3",{attrs:{id:"git简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git简介"}},[t._v("#")]),t._v(" Git简介")]),t._v(" "),e("p",[t._v("Git是目前世界上最先进的分布式版本控制系统。")]),t._v(" "),e("ol",[e("li",[t._v("版本控制")])]),t._v(" "),e("p",[t._v("典型代表Word文件的编辑，你的文件夹中是不是有这样的情况：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("word20160301.doc\nword备份的.doc\nword(小王).doc\nword-03.doc\nword.doc\n")])])]),e("p",[t._v("而某一天，你可能需要以前修改过的版本（因为，经常会遇到这种抽风的上司或者客户）")]),t._v(" "),e("p",[t._v("而由版本控制给你带来的是：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("版本    用户    说明    日期\n1   张三    删除了软件服务条款5    7/12 10:38\n2    张三    增加了License人数限制    7/12 18:09\n3    李四    财务部门调整了合同金额    7/13 9:51\n4    张三    延长了免费升级周期    7/14 15:17\n")])])]),e("p",[t._v("而且，你想退回到哪里，就可以退回到哪里！")]),t._v(" "),e("p",[t._v("记住第一个关键词：（无尽的）后悔药")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("分布式 VS 集中式")])]),t._v(" "),e("p",[t._v("集中式，典型的代表就是SVN，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。")]),t._v(" "),e("p",[t._v("分布式，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。")]),t._v(" "),e("p",[t._v("Git不单是不必联网这么简单，Git更强大的是分支管理。后面讲到~~~~~")]),t._v(" "),e("p",[t._v("记住第二个关键词：分布式")]),t._v(" "),e("h3",{attrs:{id:"git环境搭建"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git环境搭建"}},[t._v("#")]),t._v(" Git环境搭建")]),t._v(" "),e("h4",{attrs:{id:"安装git"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#安装git"}},[t._v("#")]),t._v(" 安装Git")]),t._v(" "),e("p",[t._v("在Linux(Debian)上安装Git:\napt-get install git\nMac OS X上安装Git：\n第一种方法是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。\n第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”->“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。\n在Windows上安装Git\n从这里https://git-for-windows.github.io/下载，双击安装\n安装完成后，可以在右键菜单/开始菜单中找到“Git”->“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n全局变量设置\n就像Java需要设置Path一样，Git需要设置一些全局变量。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('“Git”->“Git Bash”\n\n$ git config --global user.name "Your Name"\n$ git config --global user.email "email@example.com"\n')])])]),e("p",[t._v("设置用户与Email，相当于自报家门，让版本库有一个记录。注意：git config命令的--global是全局设置的意思。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("任何一个命令或者参考：git [命令] --help来查看帮助，或者登陆官方来学习命令http://git-scm.com/doc\n")])])]),e("p",[t._v("创建版本库")]),t._v(" "),e("ol",[e("li",[t._v("windows下，需要建立的版本库的地方，右键git bash->")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git init\n")])])]),e("p",[t._v("瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。")]),t._v(" "),e("p",[t._v("PS:如果你没有看到.git目录，那是因为这个目录默认是隐藏的")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("Linux中：")])]),t._v(" "),e("p",[t._v("如果，需要在learngit目录下建立一个Git仓库，可以如下操作")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ mkdir learngit\n$ cd learngit\n$ git init\n")])])]),e("p",[t._v("你也可以这样:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git init learngit\n")])])]),e("p",[t._v("试一试吧！")]),t._v(" "),e("h3",{attrs:{id:"基本操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本操作"}},[t._v("#")]),t._v(" 基本操作")]),t._v(" "),e("h4",{attrs:{id:"git工作区和暂存区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git工作区和暂存区"}},[t._v("#")]),t._v(" Git工作区和暂存区:")]),t._v(" "),e("p",[t._v("我们看到目录为工作区(/learngit)；需要进行提交到版本库的文件放在暂存区（看不到，需要使用git status来查看）。")]),t._v(" "),e("p",[t._v("git status命令：可以让我们时刻掌握仓库当前的状态。")]),t._v(" "),e("p",[t._v("git diff命令：让我们查看文件与版本库中的区别。")]),t._v(" "),e("p",[t._v("获取远程仓库代码（前提是init之后）")]),t._v(" "),e("ol",[e("li",[t._v("克隆仓库：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git clone [user@]example.com:path/to/repo.git/\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("或者添加远程仓库：")])]),t._v(" "),e("p",[t._v("使用git remote add命令，添加一个远程仓库的链接，命令格式：git remote add [远程仓库别名] [远程仓库地址]")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git remote add origin git@github.com:michaelliao/learngit.git\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[t._v("拉取代码。")])]),t._v(" "),e("p",[t._v("如果已经被git管理的项目，则使用git pull和git fetch来管理代码的拉取与更新：")]),t._v(" "),e("p",[t._v("使用git pull拉取远程代码的HEAD头标记，即最新的代码。")]),t._v(" "),e("p",[t._v("命令格式：$ git pull <远程主机名> <远程分支名>:<本地分支名>")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git pull \n")])])]),e("h4",{attrs:{id:"提交代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#提交代码"}},[t._v("#")]),t._v(" 提交代码")]),t._v(" "),e("p",[t._v("把所有的文件更改提交到暂存区：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git add -a\n")])])]),e("p",[t._v("为所有暂存区的代码写入日志并提交到本地仓库：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('$ git commit -m "(something)"\n')])])]),e("p",[t._v("把所有本地仓库的提交，更新到远程仓库：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git push\n")])])]),e("h4",{attrs:{id:"git时光机"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git时光机"}},[t._v("#")]),t._v(" Git时光机")]),t._v(" "),e("ol",[e("li",[t._v("git log命令：查看每次修改的日志文件。")])]),t._v(" "),e("p",[t._v("git log与git reflog的区别，记得几点：git log是顺着当前分支往前去查找提交记录，而git reflog并不像git log去遍历提交历史，它都不是仓库的一部分，它不包含推送、更新或者克隆，而是作为本地提交记录的清单。简单理解：本地后悔药。")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("git reset命令：回退命令。")])]),t._v(" "),e("p",[t._v("首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git reset --hard HEAD^\nHEAD is now at ea34578 add distributed\n")])])]),e("p",[t._v("回退add命令提交到缓存区的文件，并不会把文件恢复缓存区，需要区别（3）git checkout命令：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git reset HEAD \n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[e("p",[t._v("git checkout --命令:丢弃缓存区文件的修改，把文件恢复到git add之前的状态。")])]),t._v(" "),e("li",[e("p",[t._v("git diff HEAD --命令可以查看工作区和版本库里面最新版本的区别")])]),t._v(" "),e("li",[e("p",[t._v("git rm删除文件。")])])]),t._v(" "),e("h4",{attrs:{id:"标签管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标签管理"}},[t._v("#")]),t._v(" 标签管理")]),t._v(" "),e("p",[t._v("发布一个版本时，我们通常先在版本库中打一个标签，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。")]),t._v(" "),e("p",[t._v("Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。")]),t._v(" "),e("ol",[e("li",[t._v("创建标签（快照）")])]),t._v(" "),e("p",[t._v("在Git中打标签非常简单，首先，切换到需要打标签的分支上：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git branch\n* dev\n  master\n$ git checkout master\nSwitched to branch 'master'\n")])])]),e("p",[t._v("然后，敲命令git tag就可以打一个新标签：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git tag v1.0\n")])])]),e("p",[t._v("可以用命令git tag查看所有标签：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git tag\nv1.0\n")])])]),e("p",[t._v("默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？")]),t._v(" "),e("p",[t._v("方法是找到历史提交的commit id，然后打上就可以了：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git log --pretty=oneline --abbrev-commit\n6a5819e merged bug fix 101\ncc17032 fix bug 101\n7825a50 merge with no-ff\n6224937 add merge\n59bc1cb conflict fixed\n400b400 & simple\n75a857c AND simple\nfec145a branch test\nd17efd8 remove test.txt\n")])])]),e("p",[t._v("比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git tag v0.9 6224937\n")])])]),e("p",[t._v("再用命令git tag查看标签：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git tag\nv0.9\nv1.0\n")])])]),e("p",[t._v("注意，标签不是按时间顺序列出，而是按字母排序的。")]),t._v(" "),e("p",[t._v("可以用"),e("strong",[t._v("git show")]),t._v("查看标签信息：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git show v0.9\ncommit 622493706ab447b6bb37e4e2a2f276a20fed2ab4\nAuthor: Brian \nDate:   Thu Aug 22 11:22:08 2013 +0800\n    add merge\n")])])]),e("p",[t._v("可以看到，v0.9确实打在add merge这次提交上。")]),t._v(" "),e("p",[t._v("还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('   $ git tag -a v0.1 -m "version 0.1 released" 3628164\n')])])]),e("p",[t._v("用命令git show可以看到说明文字：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("   $ git show v0.1\n   tag v0.1\n   Tagger: Brian \n   Date:   Mon Aug 26 07:28:11 2013 +0800\n   \n   version 0.1 released\n   \n   commit 3628164fb26d48395383f8f31179f24e0882e1e0\n   Author: Brian \n   Date:   Tue Aug 20 15:11:49 2013 +0800\n   \n   append GPL\n")])])]),e("p",[t._v("还可以通过-s用私钥签名一个标签：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('   $ git tag -s v0.2 -m "signed version 0.2 released" fec145a\n')])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("标签操作（删除，推送）")])]),t._v(" "),e("p",[t._v("命令git push origin可以推送一个本地标签；")]),t._v(" "),e("p",[t._v("命令git push origin --tags可以推送全部未推送过的本地标签；")]),t._v(" "),e("p",[t._v("命令git tag -d可以删除一个本地标签；")]),t._v(" "),e("p",[t._v("命令git push origin :refs/tags/可以删除一个远程标签。")]),t._v(" "),e("p",[t._v("如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git tag -d v0.9\nDeleted tag 'v0.9' (was 6224937)\n")])])]),e("p",[t._v("然后，从远程删除。删除命令也是push，但是格式如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git push origin :refs/tags/v0.9\nTo git@github.com:michaelliao/learngit.git\n - [deleted]         v0.9\n")])])]),e("h4",{attrs:{id:"使用-gitignore忽略文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用-gitignore忽略文件"}},[t._v("#")]),t._v(" 使用.gitignore忽略文件")]),t._v(" "),e("p",[t._v("有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files …，有强迫症的童鞋心里肯定不爽。")]),t._v(" "),e("p",[t._v("好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。")]),t._v(" "),e("p",[t._v("不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore")]),t._v(" "),e("p",[t._v("忽略文件的原则是：")]),t._v(" "),e("ul",[e("li",[t._v("忽略操作系统自动生成的文件，比如缩略图等；")]),t._v(" "),e("li",[t._v("忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；")]),t._v(" "),e("li",[t._v("忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。\n举个例子：")])]),t._v(" "),e("p",[t._v("假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# Windows:\nThumbs.db\nehthumbs.db\nDesktop.ini\n")])])]),e("p",[t._v("然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# Python:\n*.py[cod]\n*.so\n*.egg\n*.egg-info\ndist\nbuild\n")])])]),e("p",[t._v("加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("# Windows:\nThumbs.db\nehthumbs.db\nDesktop.ini\n\n# Python:\n*.py[cod]\n*.so\n*.egg\n*.egg-info\ndist\nbuild\n\n# My configurations:\ndb.ini\ndeploy_key_rsa\n")])])]),e("p",[t._v("最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。")]),t._v(" "),e("p",[t._v("使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。")]),t._v(" "),e("p",[t._v("或者可以使用以下方法，在git bash中输入以下命令：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ touch .gitignore\n$ vi .gitignore\n")])])]),e("p",[t._v("Git忽略规则及.gitignore规则不生效的解决办法：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git rm -r --cached .\ngit add .\ngit commit -m 'update .gitignore'\n")])])]),e("p",[t._v("PS：注意–cached后面有一个”.”，add后面也有一个“.”")]),t._v(" "),e("p",[t._v("完成上述操作后，再重新修改.gitnore文件，并git add .添加文件到缓存区")]),t._v(" "),e("h4",{attrs:{id:"配置命令别名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置命令别名"}},[t._v("#")]),t._v(" 配置命令别名")]),t._v(" "),e("p",[t._v("有没有经常敲错命令？比如git status？status这个单词真心不好记。")]),t._v(" "),e("p",[t._v("如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。")]),t._v(" "),e("p",[t._v("我们只需要敲一行命令，告诉Git，以后st就表示status：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git config --global alias.st status\n")])])]),e("p",[t._v("好了，现在敲git st看看效果。")]),t._v(" "),e("p",[t._v("当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git config --global alias.co checkout\n$ git config --global alias.ci commit\n$ git config --global alias.br branch\n")])])]),e("p",[t._v("以后提交就可以简写成：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('$ git ci -m "bala bala bala..."\n')])])]),e("p",[t._v("--global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。")]),t._v(" "),e("p",[t._v("在撤销修改一节中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git config --global alias.unstage 'reset HEAD'\n")])])]),e("p",[t._v("当你敲入命令：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git unstage test.py\n")])])]),e("p",[t._v("实际上Git执行的是：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git reset HEAD test.py\n")])])]),e("p",[t._v("配置一个git last，让其显示最后一次提交信息：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git config --global alias.last 'log -1'\n")])])]),e("p",[t._v("这样，用git last就能显示最近一次的提交：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git last\ncommit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2\nMerge: bd6ae48 291bea8\nAuthor: Michael Liao \nDate:   Thu Aug 22 22:49:22 2013 +0800\n\nmerge & fix hello.py\n")])])]),e("p",[t._v("甚至还有人丧心病狂地把lg配置成了：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit\"\n")])])]),e("p",[t._v("来看看git lg的效果：")]),t._v(" "),e("p",[t._v("为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！")]),t._v(" "),e("h4",{attrs:{id:"配置文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#配置文件"}},[t._v("#")]),t._v(" 配置文件")]),t._v(" "),e("p",[t._v("配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。")]),t._v(" "),e("p",[t._v("配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('$ cat .git/config \n[core]\n    repositoryformatversion = 0\n    filemode = true\n    bare = false\n    logallrefupdates = true\n    ignorecase = true\n    precomposeunicode = true\n[remote "origin"]\n    url = git@github.com:michaelliao/learngit.git\n    fetch = +refs/heads/*:refs/remotes/origin/*\n[branch "master"]\n    remote = origin\n    merge = refs/heads/master\n[alias]\n    last = log -1\n')])])]),e("p",[t._v("别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。")]),t._v(" "),e("p",[t._v("而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ cat .gitconfig\n[alias]\n    co = checkout\n    ci = commit\n    br = branch\n    st = status\n[user]\n    name = Your Name\n    email = your@email.com\n")])])]),e("h3",{attrs:{id:"git恢复流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git恢复流程"}},[t._v("#")]),t._v(" Git恢复流程")]),t._v(" "),e("p",[t._v("当中心仓库由于不可抗拒因素而垮了之后：")]),t._v(" "),e("p",[t._v("项目Git恢复流程：")]),t._v(" "),e("h4",{attrs:{id:"方法一：恢复指定分支"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法一：恢复指定分支"}},[t._v("#")]),t._v(" 方法一：恢复指定分支")]),t._v(" "),e("p",[t._v("1.注册账号→输入SSH keys→新建项目。")]),t._v(" "),e("p",[t._v("2.在原项目文件夹下，使用git remote -v命令查看")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git remote -v\norigin  git@192.168.1.222:kanlidy/HelloGit.git (fetch)\norigin  git@192.168.1.222:kanlidy/HelloGit.git (push)\n")])])]),e("p",[t._v("使用git remote remove origin删除原有仓库地址。")]),t._v(" "),e("p",[t._v("3.使用新的仓库地址：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git remote add origin [ssh仓库地址]\n")])])]),e("p",[t._v("如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git remote add origin ssh://git@github.com/kanlidy/HelloGit.git\n")])])]),e("p",[t._v("4.添加文件，并Commit提交，最后push上远程指定分支")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('git add .\n\ngit commit -m "add my repo"\n\n#这条命令会把当前分支，推送到远程的master分支\ngit push origin master \n\n#如果需要把dev分支，推送到远程的dev分支\ngit push origin dev:dev\n')])])]),e("h4",{attrs:{id:"方法二：恢复项目所有分支"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#方法二：恢复项目所有分支"}},[t._v("#")]),t._v(" 方法二：恢复项目所有分支:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git remote remove origin\n\ngit remote add origin [新的SSH仓库地址]\n\ngit push --mirror ssh://git@github.com/kanlidy/LearnPython.git\n")])])]),e("h4",{attrs:{id:"本地多个ssh密钥文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#本地多个ssh密钥文件"}},[t._v("#")]),t._v(" 本地多个SSH密钥文件")]),t._v(" "),e("p",[t._v("有的时候，不仅github使用ssh key，工作项目或者其他云平台可能也需要使用ssh key来认证，如果每次都覆盖了原来的id_rsa文件，那么之前的认证就会失效。这个问题我们可以通过在~/.ssh目录下增加config文件来解决。")]),t._v(" "),e("ol",[e("li",[t._v("第一步依然是配置git用户名和邮箱")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('git config user.name "用户名"\ngit config user.email "邮箱"\n')])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("生成ssh key时同时指定保存的文件名")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('ssh-keygen -t rsa -f ~/.ssh/id_rsa.company -C "email"\n')])])]),e("p",[t._v("上面的id_rsa.company就是我们指定的文件名，这时~/.ssh目录下会多出id_rsa.company和id_rsa.company.pub两个文件，id_rsa.company.pub里保存的就是我们要使用的key。")]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("新增并配置config文件")])]),t._v(" "),e("p",[t._v("添加config文件")]),t._v(" "),e("p",[t._v("如果config文件不存在，先添加；存在则直接修改")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("touch ~/.ssh/config\n")])])]),e("p",[t._v("在config文件里添加如下内容(User表示你的用户名)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Host 域名或者IP\n    IdentityFile ~/.ssh/id_rsa.company\n    User test\n")])])]),e("p",[t._v("如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Host 192.168.1.222\nIdentityFile ~/.ssh/id_rsa.company\nUser kanlidy\n")])])]),e("p",[t._v("上传key到云平台后台(省略)")]),t._v(" "),e("p",[t._v("测试ssh key是否配置成功")]),t._v(" "),e("p",[t._v("ssh -T git@域名或者IP")]),t._v(" "),e("p",[t._v("如：")]),t._v(" "),e("p",[t._v("ssh -T git@192.168.1.222 -p 8082")]),t._v(" "),e("p",[t._v("成功的话会显示：")]),t._v(" "),e("p",[t._v("Welcome to GitLab, kanlidy!")]),t._v(" "),e("p",[t._v("至此，本地便成功配置多个ssh key。日后如需添加，则安装上述配置生成key，并修改config文件即可。")]),t._v(" "),e("h3",{attrs:{id:"git分支管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git分支管理"}},[t._v("#")]),t._v(" Git分支管理")]),t._v(" "),e("p",[t._v("还记得《星际穿越》中的平行空间吗？两个独立的空间互不干扰，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。在某一个时间点，两个平行的时空合并了，结果，你既学会了Git又学会了SVN！")]),t._v(" "),e("p",[t._v("**分支在实际中有什么用呢？**假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。")]),t._v(" "),e("p",[t._v("**分支的独立性：**现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。")]),t._v(" "),e("p",[t._v("**git分支的高效：**其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。")]),t._v(" "),e("p",[t._v("但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。")]),t._v(" "),e("h4",{attrs:{id:"理解head头指针"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#理解head头指针"}},[t._v("#")]),t._v(" 理解HEAD头指针")]),t._v(" "),e("p",[t._v("一开始的时候，HEAD头指针指向的是主分支，即master分支。而HEAD指向的是当前分支，master指向的是提交。")]),t._v(" "),e("p",[t._v("如果，在master分支上新建了一个分支dev，此时HEAD指向了dev，Git建立分支的过程很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！")]),t._v(" "),e("p",[t._v("不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。")]),t._v(" "),e("h4",{attrs:{id:"创建dev分支"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建dev分支"}},[t._v("#")]),t._v(" 创建dev分支")]),t._v(" "),e("p",[t._v("创建分支使用git branch命令，命令格式：git branch [分支别名]")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git branch dev\n")])])]),e("p",[t._v("可以使用$ git branch来查看所有本地分支，$ git branch -a查看所有分支（包括远程分支）。")]),t._v(" "),e("p",[t._v("使用git checkout [分支名]切换到对应的分支，如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git checkout dev \n")])])]),e("p",[t._v("此时，HEAD头指针会指向dev，如果在dev上提交，dev指针会往前移，而其他分支不变。（master分支及指针不变）")]),t._v(" "),e("p",[t._v("当使用git checkout master时，HEAD头指针会重新指向master，此时再提交，master指针会往前移。")]),t._v(" "),e("p",[t._v("这个过程，需要自己亲身的试验才能体会到它们的作用和变化。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$gitk\n")])])]),e("p",[t._v("使用Git自带的图形界面，可以很好的来管理分支。")]),t._v(" "),e("h4",{attrs:{id:"冲突解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#冲突解决"}},[t._v("#")]),t._v(" 冲突解决")]),t._v(" "),e("p",[t._v("冲突产生：当两个分支中修改的相同的文件并提交（add->commit），合并(merge)这两个分支的时候，会产生冲突。")]),t._v(" "),e("p",[t._v("如下例：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git checkout -b feature1\n")])])]),e("ol",[e("li",[t._v("在新的feature1分支下修改了readme.txt：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('vi readme.txt\n//修改，添加Creating a new branch is quick AND simple.\n$ git add readme.txt \n$ git commit -m "AND simple"\n')])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("切换到master分支：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('$ git checkout master\n\nvi readme.txt\n//在`master`分支上把readme.txt文件的最后一行改为：Creating a new branch is quick & simple\n$ git add readme.txt \n$ git commit -m "& simple"\n')])])]),e("ol",{attrs:{start:"3"}},[e("li",[t._v("试图合并master与feature1：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git merge feature1\nAuto-merging readme.txt\nCONFLICT (content): Merge conflict in readme.txt\nAutomatic merge failed; fix conflicts and then commit the result.\n")])])]),e("p",[t._v("（1）使用：$ git status来查看冲突文件：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('$ git status\n# On branch master\n# Your branch is ahead of \'origin/master\' by 2 commits.\n#\n# Unmerged paths:\n#   (use "git add/rm ..." as appropriate to mark resolution)\n#\n#       both modified:      readme.txt\n#\nno changes added to commit (use "git add" and/or "git commit -a")\n')])])]),e("p",[t._v("（2）直接查看readme.txt文件内容：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Git is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\nGit tracks changes of files.\n<<<<<<< HEAD\nCreating a new branch is quick & simple.\n=======\nCreating a new branch is quick AND simple.\n>>>>>>> feature1\n")])])]),e("p",[t._v("Git用<<<<<<<，=======，>>>>>>>标记出不同分支的内容，我们修改如下后保存：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Creating a new branch is quick and simple.\n")])])]),e("ol",{attrs:{start:"4"}},[e("li",[t._v("再提交：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('$ git add readme.txt \n$ git commit -m "conflict fixed"\n[master 59bc1cb] conflict fixed\n')])])]),e("p",[t._v("PS: 用带参数的git log也可以看到分支的合并情况：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git log --graph --pretty=oneline --abbrev-commit\n*   59bc1cb conflict fixed\n|\\\n| * 75a857c AND simple\n* | 400b400 & simple\n|/\n* fec145a branch test\n...\n")])])]),e("ol",{attrs:{start:"5"}},[e("li",[t._v("最后，删除feature1分支：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git branch -d feature1\nDeleted branch feature1 (was 75a857c).\n")])])]),e("h3",{attrs:{id:"分支管理策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分支管理策略"}},[t._v("#")]),t._v(" 分支管理策略")]),t._v(" "),e("p",[t._v("通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。")]),t._v(" "),e("p",[t._v("如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。")]),t._v(" "),e("p",[t._v("下面我们实战一下--no-ff方式的git merge：")]),t._v(" "),e("p",[t._v("首先，仍然创建并切换dev分支：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git checkout -b dev\nSwitched to a new branch 'dev'\n")])])]),e("p",[t._v("修改readme.txt文件，并提交一个新的commit：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('$ git add readme.txt \n$ git commit -m "add merge"\n[dev 6224937] add merge\n 1 file changed, 1 insertion(+)\n')])])]),e("p",[t._v("现在，我们切换回master：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git checkout master\nSwitched to branch 'master\n")])])]),e("p",[t._v("准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git merge --no-ff -m \"merge with no-ff\" dev\nMerge made by the 'recursive' strategy.\n readme.txt |    1 +\n 1 file changed, 1 insertion(+)\n")])])]),e("p",[t._v("分支策略")]),t._v(" "),e("p",[t._v("在实际开发中，我们应该按照几个基本原则进行分支管理：")]),t._v(" "),e("p",[t._v("首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；")]),t._v(" "),e("p",[t._v("那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；")]),t._v(" "),e("p",[t._v("你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。")]),t._v(" "),e("p",[t._v("所以，团队合作的分支看起来就像这样：")]),t._v(" "),e("h4",{attrs:{id:"bug分支"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bug分支"}},[t._v("#")]),t._v(" Bug分支")]),t._v(" "),e("p",[t._v("软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。")]),t._v(" "),e("p",[t._v("当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('$ git status\n# On branch dev\n# Changes to be committed:\n#   (use "git reset HEAD ..." to unstage)\n#\n#       new file:   hello.py\n#\n# Changes not staged for commit:\n#   (use "git add ..." to update what will be committed)\n#   (use "git checkout -- ..." to discard changes in working directory)\n#\n#       modified:   readme.txt\n#\n')])])]),e("p",[t._v("并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？")]),t._v(" "),e("p",[t._v("幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git stash\nSaved working directory and index state WIP on dev: 6224937 add merge\nHEAD is now at 6224937 add merge\n")])])]),e("p",[t._v("现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。")]),t._v(" "),e("p",[t._v("首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git checkout master\n$ git checkout -b issue-101\n")])])]),e("p",[t._v("现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('$ git add readme.txt \n$ git commit -m "fix bug 101"\n')])])]),e("p",[t._v("修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('$ git checkout master\n$ git merge --no-ff -m "merged bug fix 101" issue-101\n$ git branch -d issue-101\n')])])]),e("p",[t._v("太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git checkout dev\nSwitched to branch 'dev'\n$ git status\n# On branch dev\nnothing to commit (working directory clean)\n")])])]),e("p",[t._v("工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git stash list\nstash@{0}: WIP on dev: 6224937 add merge\n")])])]),e("p",[t._v("工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：")]),t._v(" "),e("p",[t._v("**一种方式：**用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；")]),t._v(" "),e("p",[t._v("**另一种方式：**是用git stash pop，恢复的同时把stash内容也删了：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('$ git stash pop\n# On branch dev\n# Changes to be committed:\n#   (use "git reset HEAD ..." to unstage)\n#\n#       new file:   hello.py\n#\n# Changes not staged for commit:\n#   (use "git add ..." to update what will be committed)\n#   (use "git checkout -- ..." to discard changes in working directory)\n#\n#       modified:   readme.txt\n#\nDropped refs/stash@{0} (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)\n')])])]),e("p",[t._v("再用git stash list查看，就看不到任何stash内容了：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git stash list\n")])])]),e("p",[t._v("你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git stash apply stash@{0}\n")])])]),e("h4",{attrs:{id:"删除分支"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#删除分支"}},[t._v("#")]),t._v(" 删除分支")]),t._v(" "),e("p",[t._v("软件开发中，总有无穷无尽的新的功能要不断添加进来。")]),t._v(" "),e("p",[t._v("添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。")]),t._v(" "),e("p",[t._v("还记得吗？")]),t._v(" "),e("p",[t._v("建立新的分支:git checkout -b feature-new")]),t._v(" "),e("p",[t._v('工作提交：git add --a，git commit -m "something..."')]),t._v(" "),e("p",[t._v("回到dev开发分支：git checkout dev")]),t._v(" "),e("p",[t._v("合并分支：git merge --no-ff feature-new")]),t._v(" "),e("p",[t._v("一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。")]),t._v(" "),e("p",[t._v("但是，就在此时，接到上级命令，因经费不足，新功能必须取消！虽然白干了，但是这个分支还是必须就地销毁：")]),t._v(" "),e("p",[t._v("（1）如果没有合并之前，可以简单的使用git branch -d [分支名]来删除分支（使用-D命令，强制删除分支）")]),t._v(" "),e("p",[t._v("（2）如果已经合并，除了上面的需要删除以外，还需要使用前面讲到的git reset --hard HEAD^来退回到上一个版本。")]),t._v(" "),e("p",[t._v("PS:分支的删除，不会影响到其他分支上已经合并的分支内容。")]),t._v(" "),e("h4",{attrs:{id:"多人协作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多人协作"}},[t._v("#")]),t._v(" 多人协作")]),t._v(" "),e("p",[t._v("多人协作的工作模式通常是这样：")]),t._v(" "),e("p",[t._v("首先，可以试图用git push origin branch-name推送自己的修改；")]),t._v(" "),e("p",[t._v("如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；")]),t._v(" "),e("p",[t._v("如果合并有冲突，则解决冲突，并在本地提交；")]),t._v(" "),e("p",[t._v("没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！")]),t._v(" "),e("p",[t._v("如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream branch-name origin/branch-name。")]),t._v(" "),e("p",[t._v("这就是多人协作的工作模式，一旦熟悉了，就非常简单。")]),t._v(" "),e("p",[t._v("注：所有工作流建立在已经建立了个人账户，并添加了SSH key到个人的文档中。见Profile Settings → SSH keys → Before you can add an SSH key you need to [generate it].")]),t._v(" "),e("ol",[e("li",[t._v("普通开发人员")])]),t._v(" "),e("p",[t._v("情况一：程序员A是后加入到项目中的，项目已经存在代码仓库。")]),t._v(" "),e("p",[t._v("如：git@github.com:kanlidy/HelloGit.git")]),t._v(" "),e("p",[t._v("（1）克隆版本仓库")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git clone git@github.com:kanlidy/HelloGit.git\n")])])]),e("p",[t._v("（2）建立分支")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git checkout -b (分支名)\n")])])]),e("p",[t._v("（3）提交代码")]),t._v(" "),e("p",[t._v("查看代码修改的状态：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git status \n")])])]),e("p",[t._v("添加到工作区：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git add .\n")])])]),e("p",[t._v("提交到本地仓库：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('git commit -m "（写下提交日志）"\n')])])]),e("p",[t._v("推送到服务器：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git push origin 分支名\n")])])]),e("p",[t._v("（4）在服务器上建立Merge Request，把自己的提交到远程的分支，Merge到Dev(开发分支)")]),t._v(" "),e("p",[e("strong",[t._v("情况二：程序员B是在一个新项目中，本地有一些代码，需要建立一个版本控制仓库")])]),t._v(" "),e("p",[t._v("（1）在项目目录下，初始化仓库")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git init\n")])])]),e("p",[t._v("（2）添加到git版本控制系统：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git remote add origin git@github.com:kanlidy/HelloGit.git\n")])])]),e("p",[t._v("（3）添加所有已经存在的文件到项目中：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git add .\n")])])]),e("p",[t._v("（4）提交代码到本地仓库：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('git commit -m "写下日志"\n')])])]),e("p",[t._v("（5）提交代码远程服务器")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git push origin <本地分支名>：<远程分支名>\n\ngit push origin master:master\n")])])]),e("p",[t._v("对于单人项目，情况二足以满足代码控制要求。→吕扬、刘扬。")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("仓库管理人员")])]),t._v(" "),e("p",[e("strong",[t._v("情况一：手工合并代码")])]),t._v(" "),e("p",[t._v("（1）在指定分支上获取更新")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git checkout <指定分支>\n")])])]),e("p",[t._v("（2）拉取服务器上的代码")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git pull origin <指定分支>\n")])])]),e("p",[t._v("（3）切换到dev，并获取dev上的更新，合并指定分支上的代码")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git checkout dev\ngit pull origin dev\ngit merge <指定分支>\n")])])]),e("p",[e("strong",[t._v("情况二：直接在gitlab上进行操作")])]),t._v(" "),e("p",[t._v("直接点击accept merge request进行分支合并。")]),t._v(" "),e("p",[t._v("代码回撤参考git reset命令，获取更新参考git fetch命令，分支查看git branch，逻辑流程图gitk，状态命令git status,日志命令git reflog与git log")]),t._v(" "),e("h3",{attrs:{id:"git常用命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git常用命令"}},[t._v("#")]),t._v(" Git常用命令")]),t._v(" "),e("p",[t._v("这一部分介绍了git的常用命令，如git clone、git pull、git push等等。")]),t._v(" "),e("p",[e("strong",[t._v("git clone")]),t._v("\n该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。")]),t._v(" "),e("p",[t._v("克隆仓库git clone的语法：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git clone <版本库的网址> <本地目录名>\n")])])]),e("p",[t._v("git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git clone http[s]://example.com/path/to/repo.git/\n$ git clone ssh://example.com/path/to/repo.git/\n$ git clone git://example.com/path/to/repo.git/\n$ git clone /opt/git/project.git \n$ git clone file:///opt/git/project.git\n$ git clone ftp[s]://example.com/path/to/repo.git/\n$ git clone rsync://example.com/path/to/repo.git/\n")])])]),e("p",[t._v("SSH协议还有另一种写法。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git clone [user@]example.com:path/to/repo.git/\n")])])]),e("p",[t._v("还可以使用-b和标签名来克隆指定的分支和tags：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git clone -b r01 https://github.com/xxxx/xxxx.git\n")])])]),e("p",[e("strong",[t._v("git remote")])]),t._v(" "),e("p",[t._v("为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。\n不带选项的时候，git remote命令列出所有远程主机。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git remote\norigin\n")])])]),e("p",[t._v("使用-v选项，可以参看远程主机的网址。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git remote -v\norigin  git@github.com:jquery/jquery.git (fetch)\norigin  git@github.com:jquery/jquery.git (push)\n")])])]),e("p",[t._v("上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。\n克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git clone -o jQuery https://github.com/jquery/jquery.git\n$ git remote\njQuery\n")])])]),e("p",[t._v("上面命令表示，克隆的时候，指定远程主机叫做jQuery。\ngit remote show命令加上主机名，可以查看该主机的详细信息。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git remote show <主机名>\ngit remote add命令用于添加远程主机。\n\n$ git remote add <主机名> <网址>\ngit remote rm命令用于删除远程主机。\n\n$ git remote rm <主机名>\ngit remote rename命令用于远程主机的改名。\n\n$ git remote rename <原主机名> <新主机名>\n")])])]),e("p",[e("strong",[t._v("git fetch")]),t._v("\n一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git fetch <远程主机名>\n")])])]),e("p",[t._v("上面命令将某个远程主机的更新，全部取回本地。\ngit fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。\n默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git fetch <远程主机名> <分支名>\n")])])]),e("p",[t._v("比如，取回origin主机的master分支。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git fetch origin master\n")])])]),e("p",[t._v("所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。\ngit branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git branch -r\norigin/master\n\n$ git branch -a\n* master\n  remotes/origin/master\n")])])]),e("p",[t._v("上面命令表示，本地主机的当前分支是master，远程分支是origin/master。\n取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git checkout -b newBrach origin/master\n")])])]),e("p",[t._v("上面命令表示，在origin/master的基础上，创建一个新分支。\n此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git merge origin/master\n# 或者\n$ git rebase origin/master\n")])])]),e("p",[t._v("上面命令表示在当前分支上，合并origin/master。")]),t._v(" "),e("p",[e("strong",[t._v("git pull")]),t._v("\ngit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git pull <远程主机名> <远程分支名>:<本地分支名>\n")])])]),e("p",[t._v("比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git pull origin next:master\n")])])]),e("p",[t._v("如果远程分支是与当前分支合并，则冒号后面的部分可以省略。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git pull origin next\n")])])]),e("p",[t._v("上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git fetch origin\n$ git merge origin/next\n")])])]),e("p",[t._v("在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。\nGit也允许手动建立追踪关系。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git branch --set-upstream master origin/next\n")])])]),e("p",[t._v("上面命令指定master分支追踪origin/next分支。\n如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git pull origin\n")])])]),e("p",[t._v("上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。\n如果当前分支只有一个追踪分支，连远程主机名都可以省略。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git pull\n")])])]),e("p",[t._v("上面命令表示，当前分支自动与唯一一个追踪分支进行合并。\n如果合并需要采用rebase模式，可以使用--rebase选项。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git pull --rebase <远程主机名> <远程分支名>:<本地分支名>\n")])])]),e("p",[t._v("如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。\n但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git pull -p\n# 等同于下面的命令\n$ git fetch --prune origin \n$ git fetch -p\n")])])]),e("p",[e("strong",[t._v("git push")]),t._v("\ngit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git push <远程主机名> <本地分支名>:<远程分支名>\n")])])]),e("p",[t._v("注意，分支推送顺序的写法是<来源地>:<目的地>，所以git pull是<远程分支>:<本地分支>，而git push是<本地分支>:<远程分支>。\n如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git push origin master\n")])])]),e("p",[t._v("上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。\n如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git push origin :master\n# 等同于\n$ git push origin --delete master\n")])])]),e("p",[t._v("上面命令表示删除origin主机的master分支。\n如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git push origin\n")])])]),e("p",[t._v("上面命令表示，将当前分支推送到origin主机的对应分支。\n如果当前分支只有一个追踪分支，那么主机名都可以省略。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git push\n")])])]),e("p",[t._v("如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git push -u origin master\n")])])]),e("p",[t._v("上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。\n不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git config --global push.default matching\n# 或者\n$ git config --global push.default simple\n")])])]),e("p",[t._v("还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git push --all origin\n")])])]),e("p",[t._v("上面命令表示，将所有本地分支都推送到origin主机。\n如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git push --force origin \n")])])]),e("p",[t._v("上面命令使用--force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用--force选项。\n最后，git push不会推送标签（tag），除非使用--tags选项。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$ git push origin --tags\n")])])]),e("p",[t._v("以上就是关于Git你需要知道的知识点啦，掌握以上知识点，你在工作上就可以轻松玩转Git版本控制了。")])])}),[],!1,null,null,null);a.default=i.exports}}]);